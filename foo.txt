var e: vec2<f32> = vec2<f32>(3.);
var b: f32 = 1.;
fn norm(po: vec3<f32>) -> vec3<f32> {

}
fn norm2(wq: vec2<f32>) -> vec2<f32> {

}
fn norm(po: vec3<f32>) -> vec3<f32> {
	var what: i32 = 3;
	var a: i32 = 2;
	return what;

}
var rd: vec4<f32> = vec4<f32>(0.);
fn norm(po: vec3<f32>) -> () {
	rd.x = rd.x * (2.+3.);

}
var rd: vec4<f32> = vec4<f32>(0.);
fn norm(po: vec3<f32>) -> () {
	rd.x = rd.x * (2.+3.);

}
fn main() -> () {
	for (var i: i32 = 0; i<120; i = i + 1) {
		a = 3;
	
	}
}
fn norm(po: vec3<f32>) -> () {
	var r: f32 = 2.;
	var e: f32 = 1.;

}
fn norm(po: vec3<f32>) -> () {
	if (r.x>d.x) {
		r = d;
	}

}
fn norm(po: vec3<f32>) -> () {
	if (r.x>d.x) {
		r = d;
	
	} else {
		r = 1.;
		a = 55;
	
	}
	col = col + (gl);

}
fn mainImage( fragColor: vec4<f32>,  fragCoord: vec2<f32>) -> () {

}
struct Light {
	intensity: f32;
	position: vec3<f32>;
};

[[group(?), binding(?)]]
var<uniform> myLights: Light;
const yaa: array<f32,1> = array<f32,1>(5.5);
const yaa: array<f32,2> = array<f32,2>(5.5, 8.7);
